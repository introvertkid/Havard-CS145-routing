####################################################
# DVrouter.py
# Name:
# HUID:
#####################################################

import json
from router import Router
from packet import Packet

INFINITY = 16

class DVrouter(Router):
    def __init__(self, addr, heartbeat_time):
        Router().__init__(addr)
        self.heartbeat_time = heartbeat_time
        self.last_time = 0

        self.routing_table = {self.addr: (0, self.addr)}
        self.neighbor_vectors = {}
        self.port_to_neighbor = {}
        self.neighbor_to_port = {}
        self.link_costs = {}

    def handle_packet(self, port, packet):
        # TODO
        # if packet.is_traceroute:
            # Hint: this is a normal data packet
            # If the forwarding table contains packet.dst_addr
            #   send packet based on forwarding table, e.g., self.send(port, packet)
            # pass
        # else:
            # Hint: this is a routing packet generated by your routing protocol
            # If the received distance vector is different
            #   update the local copy of the distance vector
            #   update the distance vector of this router
            #   update the forwarding table
            #   broadcast the distance vector of this router to neighbors
            # pass
        if packet.is_traceroute:
            dest = packet.dst_addr
            if dest in self.routing_table:
                next_hop = self.routing_table[dest][1]
                if next_hop in self.neighbor_to_port:
                    out_port = self.neighbor_to_port[next_hop]
                    self.send(out_port, packet)
        else:
            neighbor = packet.src_addr
            received_vector = json.loads(packet.content)
            self.neighbor_vectors[neighbor] = received_vector
            updated = False

            for dest, cost in received_vector.items():
                if dest == self.addr:
                    continue
                new_cost = self.link_costs[neighbor] + cost
                if (dest not in self.routing_table or
                    new_cost < self.routing_table[dest][0] or
                    self.routing_table[dest][1] == neighbor):
                    self.routing_table[dest] = (min(new_cost, INFINITY), neighbor)
                    updated = True

            if updated:
                self.broadcast_vector()

    def handle_new_link(self, port, endpoint, cost):
        # TODO
        #   update the distance vector of this router
        #   update the forwarding table
        #   broadcast the distance vector of this router to neighbors
        # pass

        self.port_to_neighbor[port] = endpoint
        self.neighbor_to_port[endpoint] = port
        self.link_costs[endpoint] = cost
        self.neighbor_vectors[endpoint] = {}

        self.routing_table[endpoint] = (cost, endpoint)
        self.broadcast_vector()

    def handle_remove_link(self, port):
        # TODO
        #   update the distance vector of this router
        #   update the forwarding table
        #   broadcast the distance vector of this router to neighbors
        # pass

        if port not in self.port_to_neighbor:
            return
        neighbor = self.port_to_neighbor.pop(port)
        self.neighbor_to_port.pop(neighbor, None)
        self.link_costs.pop(neighbor, None)
        self.neighbor_vectors.pop(neighbor, None)

        updated = False
        to_delete = []
        for dest, (cost, next_hop) in self.routing_table.items():
            if next_hop == neighbor:
                to_delete.append(dest)
                updated = True
        for dest in to_delete:
            self.routing_table.pop(dest, None)

        if updated:
            self.broadcast_vector()

    def handle_time(self, time_ms):
        if time_ms - self.last_time >= self.heartbeat_time:
            #   broadcast the distance vector of this router to neighbors
            self.last_time = time_ms
            self.broadcast_vector()

    def broadcast_vector(self):
        vector = {dest: cost for dest, (cost, _) in self.routing_table.items()}
        msg = json.dumps(vector)
        for neighbor, port in self.neighbor_to_port.items():
            packet = Packet(Packet.ROUTING, self.addr, neighbor, msg)
            self.send(port, packet)

    def __repr__(self):
        lines = [f"Router {self.addr} Routing Table:"]
        for dest, (cost, next_hop) in sorted(self.routing_table.items()):
            lines.append(f"  {dest} via {next_hop} cost {cost}")
        return '\n'.join(lines)
